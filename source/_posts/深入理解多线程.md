---
title: 多线程
date: 2022-09-14 18:00:05
tags: [Java基础]
categories: Java基础
---
### 深入理解多线程

#### 1、线程基础概念

​	线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。Java有6种状态（初始化，运行，阻塞，等待，等待超时，终止）

1、新建状态（New）：新创建了一个线程对象。

2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。

4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
6、等待超时（TIMED_WAITING）：具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定时等待状态：

Thread.sleep
Object.wait超时
Thread.join超时
LockSupport.parkNanos
LockSupport.parkUntil

#### 2、Thread类解析

1、控制线程执行优先级

```
    /**
     * 线程可以拥有的最低优先级
     */
    public final static int MIN_PRIORITY = 1;

   /**
     * 线程默认的优先级
     */
    public final static int NORM_PRIORITY = 5;

    /**
     * 线程最大优先级
     */
    public final static int MAX_PRIORITY = 10;
```

通过getPriority() setPriority()来获取喝设置线程优先级，

1、java线程是通过映射到系统的原生线程上来实现的，所以线程的调度最终还是取决于操作系统，操作系统的优先级与java的优先级并不一一对应，如果操作系统的优先级级数大于java的优先级级数（10级）还好，但是如果小于得的话就不行了，这样会导致不同优先级的线程的优先级是一样的。
2、优先级可能会被系统自动改变，比如windows系统中就存在一个优先级推进器，大致功能就是如果一个线程执行的次数过多的话，可能会越过优先级为他分配执行时间。

**如果严格按照优先级，那么可能会出现某个线程一直不执行的情况**



